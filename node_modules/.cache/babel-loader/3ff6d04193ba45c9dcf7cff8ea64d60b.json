{"ast":null,"code":"'use strict';\n\nconst isNode = require('detect-node');\n\nconst flatmap = require('flatmap');\n\nconst {\n  Readable\n} = require('readable-stream');\n\nconst kindOf = require('kind-of');\n\nconst {\n  isSource\n} = require('is-pull-stream');\n\nconst isStream = require('is-stream');\n\nconst pullToStream = require('pull-to-stream');\n\nconst {\n  supportsFileReader\n} = require('ipfs-utils/src/supports');\n\nconst streamFromFileReader = require('ipfs-utils/src/streams/stream-from-filereader');\n\nfunction loadPaths(opts, file) {\n  const path = require('path');\n\n  const fs = require('fs');\n\n  const glob = require('glob');\n\n  const followSymlinks = opts.followSymlinks != null ? opts.followSymlinks : true;\n  file = path.resolve(file);\n  const stats = fs.statSync(file);\n\n  if (stats.isDirectory() && !opts.recursive) {\n    throw new Error('Can only add directories using --recursive');\n  }\n\n  if (stats.isDirectory() && opts.recursive) {\n    // glob requires a POSIX filename\n    file = file.split(path.sep).join('/');\n    const fullDir = file + (file.endsWith('/') ? '' : '/');\n    let dirName = fullDir.split('/');\n    dirName = dirName[dirName.length - 2] + '/';\n    const mg = new glob.sync.GlobSync('**/*', {\n      cwd: file,\n      follow: followSymlinks,\n      dot: opts.hidden,\n      ignore: opts.ignore\n    });\n    return mg.found.map(name => {\n      const fqn = fullDir + name; // symlinks\n\n      if (mg.symlinks[fqn] === true) {\n        return {\n          path: dirName + name,\n          symlink: true,\n          dir: false,\n          content: fs.readlinkSync(fqn)\n        };\n      } // files\n\n\n      if (mg.cache[fqn] === 'FILE') {\n        return {\n          path: dirName + name,\n          symlink: false,\n          dir: false,\n          content: fs.createReadStream(fqn)\n        };\n      } // directories\n\n\n      if (mg.cache[fqn] === 'DIR' || mg.cache[fqn] instanceof Array) {\n        return {\n          path: dirName + name,\n          symlink: false,\n          dir: true\n        };\n      } // files inside symlinks and others\n\n    }) // filter out null files\n    .filter(Boolean);\n  }\n\n  return {\n    path: path.basename(file),\n    content: fs.createReadStream(file)\n  };\n}\n\nfunction contentToStream(content) {\n  if (supportsFileReader && kindOf(content) === 'file') {\n    return streamFromFileReader(content);\n  }\n\n  if (kindOf(content) === 'buffer') {\n    return new Readable({\n      read() {\n        this.push(content);\n        this.push(null);\n      }\n\n    });\n  }\n\n  if (isSource(content)) {\n    return pullToStream.readable(content);\n  }\n\n  if (isStream.readable(content)) {\n    return content;\n  }\n\n  throw new Error(`Input not supported. Expected Buffer|ReadableStream|PullStream|File got ${kindOf(content)}. Check the documentation for more info https://github.com/ipfs/interface-js-ipfs-core/blob/master/SPEC/FILES.md#add`);\n}\n\nfunction prepareFile(file, opts) {\n  let files = [].concat(file);\n  return flatmap(files, file => {\n    // add from fs with file path\n    if (typeof file === 'string') {\n      if (!isNode) {\n        throw new Error('Can only add file paths in node');\n      }\n\n      return loadPaths(opts, file);\n    } // add with object syntax { path : <string> , content: <Buffer|ReadableStream|PullStream|File }\n\n\n    if (kindOf(file) === 'object') {\n      // treat as an empty directory when path is a string and content undefined\n      if (file.path && kindOf(file.path) === 'string' && !file.content) {\n        file.dir = true;\n        return file;\n      } // just return when directory\n\n\n      if (file.dir) {\n        return file;\n      }\n\n      if (file.content) {\n        return {\n          path: file.path || '',\n          symlink: false,\n          dir: false,\n          content: contentToStream(file.content)\n        };\n      }\n    }\n\n    return {\n      path: '',\n      symlink: false,\n      dir: false,\n      content: contentToStream(file)\n    };\n  });\n}\n\nexports = module.exports = prepareFile;","map":{"version":3,"sources":["/Users/shuowang/ETM/Leekdao/leekdao-farm/node_modules/ipfs-http-client/src/utils/prepare-file.js"],"names":["isNode","require","flatmap","Readable","kindOf","isSource","isStream","pullToStream","supportsFileReader","streamFromFileReader","loadPaths","opts","file","path","fs","glob","followSymlinks","resolve","stats","statSync","isDirectory","recursive","Error","split","sep","join","fullDir","endsWith","dirName","length","mg","sync","GlobSync","cwd","follow","dot","hidden","ignore","found","map","name","fqn","symlinks","symlink","dir","content","readlinkSync","cache","createReadStream","Array","filter","Boolean","basename","contentToStream","read","push","readable","prepareFile","files","concat","exports","module"],"mappings":"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","sourcesContent":["'use strict'\n\nconst isNode = require('detect-node')\nconst flatmap = require('flatmap')\nconst { Readable } = require('readable-stream')\nconst kindOf = require('kind-of')\nconst { isSource } = require('is-pull-stream')\nconst isStream = require('is-stream')\nconst pullToStream = require('pull-to-stream')\nconst { supportsFileReader } = require('ipfs-utils/src/supports')\nconst streamFromFileReader = require('ipfs-utils/src/streams/stream-from-filereader')\n\nfunction loadPaths (opts, file) {\n  const path = require('path')\n  const fs = require('fs')\n  const glob = require('glob')\n\n  const followSymlinks = opts.followSymlinks != null ? opts.followSymlinks : true\n\n  file = path.resolve(file)\n  const stats = fs.statSync(file)\n\n  if (stats.isDirectory() && !opts.recursive) {\n    throw new Error('Can only add directories using --recursive')\n  }\n\n  if (stats.isDirectory() && opts.recursive) {\n    // glob requires a POSIX filename\n    file = file.split(path.sep).join('/')\n    const fullDir = file + (file.endsWith('/') ? '' : '/')\n    let dirName = fullDir.split('/')\n    dirName = dirName[dirName.length - 2] + '/'\n    const mg = new glob.sync.GlobSync('**/*', {\n      cwd: file,\n      follow: followSymlinks,\n      dot: opts.hidden,\n      ignore: opts.ignore\n    })\n\n    return mg.found\n      .map((name) => {\n        const fqn = fullDir + name\n        // symlinks\n        if (mg.symlinks[fqn] === true) {\n          return {\n            path: dirName + name,\n            symlink: true,\n            dir: false,\n            content: fs.readlinkSync(fqn)\n          }\n        }\n\n        // files\n        if (mg.cache[fqn] === 'FILE') {\n          return {\n            path: dirName + name,\n            symlink: false,\n            dir: false,\n            content: fs.createReadStream(fqn)\n          }\n        }\n\n        // directories\n        if (mg.cache[fqn] === 'DIR' || mg.cache[fqn] instanceof Array) {\n          return {\n            path: dirName + name,\n            symlink: false,\n            dir: true\n          }\n        }\n        // files inside symlinks and others\n      })\n      // filter out null files\n      .filter(Boolean)\n  }\n\n  return {\n    path: path.basename(file),\n    content: fs.createReadStream(file)\n  }\n}\n\nfunction contentToStream (content) {\n  if (supportsFileReader && kindOf(content) === 'file') {\n    return streamFromFileReader(content)\n  }\n\n  if (kindOf(content) === 'buffer') {\n    return new Readable({\n      read () {\n        this.push(content)\n        this.push(null)\n      }\n    })\n  }\n\n  if (isSource(content)) {\n    return pullToStream.readable(content)\n  }\n\n  if (isStream.readable(content)) {\n    return content\n  }\n\n  throw new Error(`Input not supported. Expected Buffer|ReadableStream|PullStream|File got ${kindOf(content)}. Check the documentation for more info https://github.com/ipfs/interface-js-ipfs-core/blob/master/SPEC/FILES.md#add`)\n}\n\nfunction prepareFile (file, opts) {\n  let files = [].concat(file)\n\n  return flatmap(files, (file) => {\n    // add from fs with file path\n    if (typeof file === 'string') {\n      if (!isNode) {\n        throw new Error('Can only add file paths in node')\n      }\n\n      return loadPaths(opts, file)\n    }\n\n    // add with object syntax { path : <string> , content: <Buffer|ReadableStream|PullStream|File }\n    if (kindOf(file) === 'object') {\n      // treat as an empty directory when path is a string and content undefined\n      if (file.path && kindOf(file.path) === 'string' && !file.content) {\n        file.dir = true\n        return file\n      }\n\n      // just return when directory\n      if (file.dir) {\n        return file\n      }\n\n      if (file.content) {\n        return {\n          path: file.path || '',\n          symlink: false,\n          dir: false,\n          content: contentToStream(file.content)\n        }\n      }\n    }\n\n    return {\n      path: '',\n      symlink: false,\n      dir: false,\n      content: contentToStream(file)\n    }\n  })\n}\n\nexports = module.exports = prepareFile\n"]},"metadata":{},"sourceType":"script"}