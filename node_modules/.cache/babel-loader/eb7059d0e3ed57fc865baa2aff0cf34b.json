{"ast":null,"code":"'use strict';\n/* global self */\n\nconst isIPFS = require('is-ipfs');\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst CID = require('cids');\n\nconst multiaddr = require('multiaddr');\n\nconst multibase = require('multibase');\n\nconst multicodec = require('multicodec');\n\nconst multihash = require('multihashes');\n\nconst PeerId = require('peer-id');\n\nconst PeerInfo = require('peer-info');\n\nconst loadCommands = require('./utils/load-commands');\n\nconst getConfig = require('./utils/default-config');\n\nconst sendRequest = require('./utils/send-request');\n\nfunction ipfsClient(hostOrMultiaddr, port, userOptions) {\n  // convert all three params to objects that we can merge.\n  let options = {};\n\n  if (!hostOrMultiaddr) {\n    // autoconfigure host and port in browser\n    if (typeof self !== 'undefined') {\n      options = urlToOptions(self.location);\n    }\n  } else if (multiaddr.isMultiaddr(hostOrMultiaddr)) {\n    options = maToOptions(hostOrMultiaddr);\n  } else if (typeof hostOrMultiaddr === 'object') {\n    options = hostOrMultiaddr;\n  } else if (typeof hostOrMultiaddr === 'string') {\n    if (hostOrMultiaddr[0] === '/') {\n      // throws if multiaddr is malformed or can't be converted to a nodeAddress\n      options = maToOptions(multiaddr(hostOrMultiaddr));\n    } else {\n      // hostOrMultiaddr is domain or ip address as a string\n      options.host = hostOrMultiaddr;\n    }\n  }\n\n  if (port && typeof port !== 'object') {\n    port = {\n      port: port\n    };\n  }\n\n  const config = Object.assign(getConfig(), options, port, userOptions);\n  const requestAPI = sendRequest(config);\n  const cmds = loadCommands(requestAPI, config);\n  cmds.send = requestAPI;\n  return cmds;\n}\n\nfunction maToOptions(multiaddr) {\n  // ma.nodeAddress() throws if multiaddr can't be converted to a nodeAddress\n  const nodeAddr = multiaddr.nodeAddress();\n  const protos = multiaddr.protos(); // only http and https are allowed as protocol,\n  // anything else will be replaced with http\n\n  const exitProtocol = protos[protos.length - 1].name;\n  return {\n    host: nodeAddr.address,\n    port: nodeAddr.port,\n    protocol: exitProtocol.startsWith('http') ? exitProtocol : 'http'\n  };\n}\n\nfunction urlToOptions(url) {\n  return {\n    host: url.hostname,\n    port: url.port || (url.protocol.startsWith('https') ? 443 : 80),\n    protocol: url.protocol.startsWith('http') ? url.protocol.split(':')[0] : 'http'\n  };\n}\n\nmodule.exports = ipfsClient;\nObject.assign(module.exports, {\n  isIPFS,\n  Buffer,\n  CID,\n  multiaddr,\n  multibase,\n  multicodec,\n  multihash,\n  PeerId,\n  PeerInfo\n});","map":{"version":3,"sources":["/Users/shuowang/ETM/Leekdao/leekdao-farm/node_modules/ipfs-http-client/src/index.js"],"names":["isIPFS","require","Buffer","CID","multiaddr","multibase","multicodec","multihash","PeerId","PeerInfo","loadCommands","getConfig","sendRequest","ipfsClient","hostOrMultiaddr","port","userOptions","options","self","urlToOptions","location","isMultiaddr","maToOptions","host","config","Object","assign","requestAPI","cmds","send","nodeAddr","nodeAddress","protos","exitProtocol","length","name","address","protocol","startsWith","url","hostname","split","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n/* global self */\n\nconst isIPFS = require('is-ipfs')\nconst { Buffer } = require('buffer')\nconst CID = require('cids')\nconst multiaddr = require('multiaddr')\nconst multibase = require('multibase')\nconst multicodec = require('multicodec')\nconst multihash = require('multihashes')\nconst PeerId = require('peer-id')\nconst PeerInfo = require('peer-info')\nconst loadCommands = require('./utils/load-commands')\nconst getConfig = require('./utils/default-config')\nconst sendRequest = require('./utils/send-request')\n\nfunction ipfsClient (hostOrMultiaddr, port, userOptions) {\n  // convert all three params to objects that we can merge.\n  let options = {}\n\n  if (!hostOrMultiaddr) {\n    // autoconfigure host and port in browser\n    if (typeof self !== 'undefined') {\n      options = urlToOptions(self.location)\n    }\n  } else if (multiaddr.isMultiaddr(hostOrMultiaddr)) {\n    options = maToOptions(hostOrMultiaddr)\n  } else if (typeof hostOrMultiaddr === 'object') {\n    options = hostOrMultiaddr\n  } else if (typeof hostOrMultiaddr === 'string') {\n    if (hostOrMultiaddr[0] === '/') {\n      // throws if multiaddr is malformed or can't be converted to a nodeAddress\n      options = maToOptions(multiaddr(hostOrMultiaddr))\n    } else {\n      // hostOrMultiaddr is domain or ip address as a string\n      options.host = hostOrMultiaddr\n    }\n  }\n\n  if (port && typeof port !== 'object') {\n    port = { port: port }\n  }\n\n  const config = Object.assign(getConfig(), options, port, userOptions)\n  const requestAPI = sendRequest(config)\n  const cmds = loadCommands(requestAPI, config)\n  cmds.send = requestAPI\n\n  return cmds\n}\n\nfunction maToOptions (multiaddr) {\n  // ma.nodeAddress() throws if multiaddr can't be converted to a nodeAddress\n  const nodeAddr = multiaddr.nodeAddress()\n  const protos = multiaddr.protos()\n  // only http and https are allowed as protocol,\n  // anything else will be replaced with http\n  const exitProtocol = protos[protos.length - 1].name\n  return {\n    host: nodeAddr.address,\n    port: nodeAddr.port,\n    protocol: exitProtocol.startsWith('http') ? exitProtocol : 'http'\n  }\n}\n\nfunction urlToOptions (url) {\n  return {\n    host: url.hostname,\n    port: url.port || (url.protocol.startsWith('https') ? 443 : 80),\n    protocol: url.protocol.startsWith('http') ? url.protocol.split(':')[0] : 'http'\n  }\n}\n\nmodule.exports = ipfsClient\n\nObject.assign(module.exports, { isIPFS, Buffer, CID, multiaddr, multibase, multicodec, multihash, PeerId, PeerInfo })\n"]},"metadata":{},"sourceType":"script"}