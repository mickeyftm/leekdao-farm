{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$();\n\nimport { useEffect, useState } from \"react\";\nimport axios from \"axios\";\nimport { useAirdropContract } from \"hooks/useContract\";\nimport useRefresh from 'hooks/useRefresh';\nconst url = process.env.REACT_APP_API_URL;\nconst username = process.env.REACT_APP_API_USERNAME;\nconst password = process.env.REACT_APP_API_PASSWORD;\nexport const usePostParticipation = formData => {\n  _s();\n\n  const [successData, setSuccessData] = useState(null);\n  const customUrl = `${url}/airdrop`;\n  useEffect(() => {\n    let mounted = true;\n\n    const fetchData = async () => {\n      try {\n        const {\n          data\n        } = await axios.post(customUrl, formData, {\n          auth: {\n            username,\n            password\n          }\n        });\n\n        if (mounted) {\n          setSuccessData(data);\n        }\n      } catch (error) {\n        console.error('Unable to post participation data:', error.response);\n      }\n    };\n\n    fetchData();\n    return () => {\n      mounted = false;\n    };\n  }, [customUrl, formData, setSuccessData]);\n  return successData;\n};\n\n_s(usePostParticipation, \"f6Ba9vrUj1aZ7z7GhGCsfxCB52A=\");\n\nexport const useGetAirdropInfo = () => {\n  _s2();\n\n  const [airdropInfo, setAirdropInfo] = useState({});\n  const contract = useAirdropContract();\n  const {\n    fastRefresh\n  } = useRefresh();\n  useEffect(() => {\n    let mounted = true;\n\n    const fetchData = async () => {\n      try {\n        const [startBlock, endBlock, airdropAmount, vipAirdropAmount, remainingAmount] = await Promise.all([contract.methods.startBlockNumber().call(), contract.methods.finishBlockNumber().call(), contract.methods.airdropAmount().call(), contract.methods.vipAirdropAmount().call(), contract.methods.remainingTokens().call()]);\n\n        if (mounted) {\n          setAirdropInfo({\n            startBlock,\n            endBlock,\n            airdropAmount,\n            vipAirdropAmount,\n            remainingAmount\n          });\n        }\n      } catch (err) {\n        console.error(\"Unable to fetch airdrop info\", err.response);\n      }\n    };\n\n    fetchData();\n    return () => {\n      mounted = false;\n    };\n  }, [contract.methods, fastRefresh]);\n  return airdropInfo;\n};\n\n_s2(useGetAirdropInfo, \"4DJINutNUEhUYJ22xRlKsJ34PL4=\", false, function () {\n  return [useAirdropContract, useRefresh];\n});\n\nexport const useGetAirdropList = isVip => {\n  _s3();\n\n  const [airdropList, setAirdropList] = useState(null);\n  const customUrl = `${url}/airdropList`;\n  const {\n    fastRefresh\n  } = useRefresh();\n  useEffect(() => {\n    let mounted = true;\n\n    const fetchData = async () => {\n      try {\n        const {\n          data\n        } = await axios.get(customUrl, {\n          params: {\n            isVip\n          }\n        });\n\n        if (mounted) {\n          setAirdropList(data);\n        }\n      } catch (error) {\n        console.error('Unable to fetch airdrop list:', error.response);\n      }\n    };\n\n    fetchData();\n    return () => {\n      mounted = false;\n    };\n  }, [customUrl, isVip, setAirdropList, fastRefresh]);\n  return airdropList;\n};\n\n_s3(useGetAirdropList, \"wjH283Y4C3jK9TlaoVhOxrM+bKk=\", false, function () {\n  return [useRefresh];\n});\n\nexport const updateAirdropParticipationStatus = async isVip => {\n  const customUrl = `${url}/airdropParticipationStatus`;\n  await axios.patch(customUrl, {\n    isVip\n  }, {\n    auth: {\n      username,\n      password\n    }\n  });\n};\nexport const useIsVIP = account => {\n  _s4();\n\n  const [isVIP, setIsVIP] = useState(false);\n  const contract = useAirdropContract();\n  const {\n    slowRefresh\n  } = useRefresh();\n  useEffect(() => {\n    let mounted = true;\n\n    const fetchData = async () => {\n      try {\n        if (account) {\n          const response = await contract.methods.isVIP(account).call();\n\n          if (mounted) {\n            setIsVIP(response);\n          }\n        }\n      } catch (err) {\n        console.error(\"Unable to identify whether is VIP\", err.response);\n      }\n    };\n\n    fetchData();\n    return () => {\n      mounted = false;\n    };\n  }, [contract.methods, account, slowRefresh]);\n  return isVIP;\n};\n\n_s4(useIsVIP, \"EK2dVrlLKTXEvljqKsSXMWNw/Ao=\", false, function () {\n  return [useAirdropContract, useRefresh];\n});\n\nexport const useIsWhiteListed = account => {\n  _s5();\n\n  const [isWhitelisted, setIsWhitelisted] = useState(false);\n  const contract = useAirdropContract();\n  const {\n    slowRefresh\n  } = useRefresh();\n  useEffect(() => {\n    let mounted = true;\n\n    const fetchData = async () => {\n      try {\n        if (account) {\n          const response = await contract.methods.isWhitelisted(account).call();\n\n          if (mounted) {\n            setIsWhitelisted(response);\n          }\n        }\n      } catch (err) {\n        console.error(\"Unable to identify whether is whitelisted\", err.response);\n      }\n    };\n\n    fetchData();\n    return () => {\n      mounted = false;\n    };\n  }, [contract.methods, account, slowRefresh]);\n  return isWhitelisted;\n};\n\n_s5(useIsWhiteListed, \"zGvkt4ZIO8A+YxqDbxoJDxKg1yM=\", false, function () {\n  return [useAirdropContract, useRefresh];\n});","map":{"version":3,"sources":["/Users/shuowang/ETM/Leekdao/leekdao-farm/src/views/Airdrop/api/index.ts"],"names":["useEffect","useState","axios","useAirdropContract","useRefresh","url","process","env","REACT_APP_API_URL","username","REACT_APP_API_USERNAME","password","REACT_APP_API_PASSWORD","usePostParticipation","formData","successData","setSuccessData","customUrl","mounted","fetchData","data","post","auth","error","console","response","useGetAirdropInfo","airdropInfo","setAirdropInfo","contract","fastRefresh","startBlock","endBlock","airdropAmount","vipAirdropAmount","remainingAmount","Promise","all","methods","startBlockNumber","call","finishBlockNumber","remainingTokens","err","useGetAirdropList","isVip","airdropList","setAirdropList","get","params","updateAirdropParticipationStatus","patch","useIsVIP","account","isVIP","setIsVIP","slowRefresh","useIsWhiteListed","isWhitelisted","setIsWhitelisted"],"mappings":"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","sourcesContent":["import { useEffect, useState } from \"react\"\nimport axios from \"axios\"\nimport { useAirdropContract } from \"hooks/useContract\"\nimport useRefresh from 'hooks/useRefresh'\n\nconst url = process.env.REACT_APP_API_URL;\nconst username = process.env.REACT_APP_API_USERNAME\nconst password = process.env.REACT_APP_API_PASSWORD\n\ninterface airdropInfo {\n    startBlock?: number\n    endBlock?: number\n    airdropAmount?: number\n    vipAirdropAmount?: number\n    remainingAmount?: number\n}\n\nexport const usePostParticipation = (formData) => {\n    const [successData, setSuccessData] = useState(null);\n    const customUrl = `${url}/airdrop`;\n\n    useEffect(() => {\n        let mounted = true\n        const fetchData = async () => {\n            try {\n                const { data } = await axios.post(customUrl,\n                    formData,\n                    {\n                        auth: {\n                            username,\n                            password\n                        }\n                    }\n                )\n                if (mounted) {\n                    setSuccessData(data)\n                }\n            } catch (error) {\n                console.error('Unable to post participation data:', error.response)\n            }\n        }\n        fetchData()\n        return () => {\n            mounted = false\n        }\n    }, [customUrl, formData, setSuccessData])\n\n    return successData\n}\n\n\nexport const useGetAirdropInfo = () => {\n    const [airdropInfo, setAirdropInfo] = useState<airdropInfo>({})\n    const contract = useAirdropContract()\n    const { fastRefresh } = useRefresh()\n\n    useEffect(() => {\n        let mounted = true;\n        const fetchData = async () => {\n            try {\n                const [startBlock, endBlock, airdropAmount, vipAirdropAmount, remainingAmount] = await Promise.all([\n                    contract.methods.startBlockNumber().call(),\n                    contract.methods.finishBlockNumber().call(),\n                    contract.methods.airdropAmount().call(),\n                    contract.methods.vipAirdropAmount().call(),\n                    contract.methods.remainingTokens().call(),\n                ])\n\n                if (mounted) {\n                    setAirdropInfo({\n                        startBlock,\n                        endBlock,\n                        airdropAmount,\n                        vipAirdropAmount,\n                        remainingAmount\n                    })\n                }\n            } catch (err) {\n                console.error(\"Unable to fetch airdrop info\", err.response)\n            }\n        }\n        fetchData();\n        return () => {\n            mounted = false\n        }\n    }, [contract.methods, fastRefresh])\n    return airdropInfo\n}\n\n\nexport const useGetAirdropList = (isVip: boolean) => {\n    const [airdropList, setAirdropList] = useState(null)\n    const customUrl = `${url}/airdropList`;\n    const { fastRefresh } = useRefresh()\n\n    useEffect(() => {\n        let mounted = true;\n        const fetchData = async () => {\n            try {\n                const { data } = await axios.get(customUrl, {\n                    params: {\n                        isVip\n                    }\n                })\n\n                if (mounted) {\n                    setAirdropList(data)\n                }\n            } catch (error) {\n                console.error('Unable to fetch airdrop list:', error.response)\n            }\n        }\n        fetchData()\n        return () => {\n            mounted = false\n        }\n    }, [customUrl, isVip, setAirdropList, fastRefresh])\n\n    return airdropList\n}\n\nexport const updateAirdropParticipationStatus = async (isVip) => {\n    const customUrl = `${url}/airdropParticipationStatus`;\n    await axios.patch(customUrl, {\n        isVip\n    }, {\n        auth: {\n            username,\n            password\n        }\n    })\n}\n\nexport const useIsVIP = (account: string | undefined) => {\n    const [isVIP, setIsVIP] = useState(false)\n    const contract = useAirdropContract()\n    const { slowRefresh } = useRefresh()\n\n    useEffect(() => {\n        let mounted = true;\n        const fetchData = async () => {\n            try {\n                if (account) {\n                    const response = await contract.methods.isVIP(account).call()\n\n                    if (mounted) {\n                        setIsVIP(response)\n                    }\n                }\n\n            } catch (err) {\n                console.error(\"Unable to identify whether is VIP\", err.response)\n            }\n        }\n        fetchData();\n        return () => {\n            mounted = false\n        }\n    }, [contract.methods, account, slowRefresh])\n    return isVIP\n}\n\nexport const useIsWhiteListed = (account: string | undefined) => {\n    const [isWhitelisted, setIsWhitelisted] = useState(false)\n    const contract = useAirdropContract()\n    const { slowRefresh } = useRefresh()\n\n    useEffect(() => {\n        let mounted = true;\n        const fetchData = async () => {\n            try {\n                if (account) {\n                    const response = await contract.methods.isWhitelisted(account).call()\n\n                    if (mounted) {\n                        setIsWhitelisted(response)\n                    }\n                }\n            } catch (err) {\n                console.error(\"Unable to identify whether is whitelisted\", err.response)\n            }\n        }\n        fetchData();\n        return () => {\n            mounted = false\n        }\n    }, [contract.methods, account, slowRefresh])\n    return isWhitelisted\n}\n\n\n\n\n\n\n"]},"metadata":{},"sourceType":"module"}